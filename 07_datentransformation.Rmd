---
title: "Datentransformation"
author: CorrelAid e.V.
date: "`r Sys.Date()`"
authors:
  - Zoé Wolter
  - Jonas Lorenz
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: flatly
    css: www/style.css
    includes:
      after_body: ./www/favicon.html
    language: de
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(learnr)
library(gradethis)
library(forcats)
 
source("R/setup/gradethis-setup.R")
source("R/setup/tutorial-setup.R")
# Read app parameters
params <- yaml::yaml.load_file("www/app_parameters.yml")

# Benötigte Daten laden
source("R/setup/functions.R")
data_raw <- get_data_raw()
community <- get_community()
plastics_processed <- get_pl_proc()
audit <- get_audit()
wb_areas <- get_wb_areas()
wb_processed <- process_wb_areas(wb_data = wb_areas)
```

```{r results='asis'}
cat(get_license_note(rmarkdown::metadata$title, rmarkdown::metadata$authors))
```

![*Video: Datentransformation mit Tidyverse (30min)*](https://youtu.be/YWFLSovbha0)

# **Das Tidyverse-Package**

<left>

![](https://www.tidyverse.org/images/hex-tidyverse.png){#id .class width=20% height=100%}

</left>
<br>

## **Zusammenfassung**

- **Sammlung verschiedener R-Packages**, die aufeinander abgestimmt sind und dabei derselben Logik folgen ([tidyverse.org](https://www.tidyverse.org/){target="_blank"}).
  - Die Packages können einzeln installiert und aufgerufen werden, aber auch gesammelt über `install_packages('tidyverse')` bzw. `library(tidyverse)`. 
- Einige der Packages und Funktionen kennen wir bereits aus den letzten Wochen!
- "tidy" Datensätze sind die Voraussetzung, um mit dem Tidyverse arbeiten zu können:

![Tidy Data](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/tidy-data.jpeg?raw=true){#id .class width=60% height=60%}
*Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst*

## **Die wichtigsten Funktionen des Tidyverse**

Hier nochmal ein kurzer Überblick, welche Packages alle im `Tidyverse`enthalten sind und was wir ungefähr mit diesen anstellen können, denn das ist eine ganze Menge:

  - **`ggplot2`**: Ermöglicht das Erstellen von komplexen und ästhetisch ansprechenden Grafiken basierend auf der Grammatik der Grafiken. Ideal für Datenvisualisierung in einer Vielzahl von Formaten.
  - **`dplyr`**: Bietet eine Reihe von Funktionen zur Datenmanipulation, wie z. B. Filtern, Sortieren, Gruppieren und Summarieren von Daten. Es ist besonders nützlich für die Arbeit mit DataFrames.
  - **`tidyr`**: Hilft dabei, Daten in ein „tidy“ Format zu bringen, bei dem jede Variable eine Spalte und jede Beobachtung eine Zeile ist. Es ermöglicht das Aufbereiten und Umformen von Daten.
  - **`readr`**: Dient dem schnellen und effizienten Einlesen von Daten in R, insbesondere von textbasierten Dateiformaten wie CSV, TSV und anderen strukturierten Textdateien.
  - **`purrr`**: Stellt Funktionen zur Verfügung, die das funktionale Programmieren in R ermöglichen und erleichtern, insbesondere das Arbeiten mit Listen und deren Daten.
  - **`tibble`**: Eine moderne Alternative zu den traditionellen DataFrames in R, die verbesserte Ausdruckskraft und Benutzerfreundlichkeit bietet. Tibbles zeigen Daten auf eine kontrollierte und übersichtliche Weise an.
  - **`stringr`**: Bietet eine konsistente und einfache Schnittstelle zur Manipulation und Analyse von Zeichenketten (Strings) in R. Ideal für Textverarbeitung und Mustererkennung.
  - **`forcats`**: Speziell für die Arbeit mit Faktoren entwickelt, die eine spezielle Datenstruktur in R für kategorische Daten sind. Es vereinfacht das Sortieren, Reordnen und Zusammenfassen von Faktorebenen.

Alle weiteren Informationen, Links, etc. findet Ihr auch [hier](https://www.tidyverse.org/packages/){target="_blank"}.

## **Wiederholung: Die Pipe `%>%`**

Bei der ersten Einführung in R haben wir bereits mit der Funktion `nrow()` Bekanntschaft gemacht. Diese können wir nutzen, um die Zeilenanzahl unseres Datensatzes herauszufinden. Zu Beginn des Kurses haben wir damals noch mit der Funktion `nrow(data_raw)` gearbeitet, die Teil von `base R` ist. In der Zwischenzeit haben wir eine ganze Menge R-Erfahrung gesammelt und sind einen Schritt weiter: Wir haben verschiedene Packages und darin enthaltene Funktionen kennengelernt. So auch die **Pipe-Operator `(%>%)`** aus dem `tidyverse`! Das ist ein sehr nützliches Tool mit dem wir die Lesbarkeit und Nachvollziehbarkeit unseres Codes verbessern können. Wir können den Output einer Funktion direkt als Input für die nächste Funktion weitergeben, d.h. mehrere Funktionen mit einer „Pipeline“ verknüpfen. Dadurch wird unser Code deutlich strukturierter und nachvollziehbarer, da die Daten in einem Schritt durch eine Reihe von Funktionen geleitet wird. Trotzdem ist jede Funktion klar und eigenständig, wodurch wir Fehler weiterhin einfach anpassen oder korrigieren können. Unsere Datenbearbeitung wird dadurch deutlich „flüssiger“, da die Daten durch die verschiedenen Schritte „fließen“, ohne dass wir uns um temporäre Variablen kümmern müssen. 
Wir können nun also den **Pipe-Operator** anstatt der Funktion `ncol(plastics)` verwenden, um die Spaltenanzahl zu bestimmen:

``` {r 07pipebeispiel, exercise = TRUE}
# Berechnung der Spaltenanzahl
data_raw %>%
  ncol()
```

Das Gleiche gilt für die Anzahl der Zeilen. Nutzt auch hier die Pipe, um Euch die Anzahl der Beobachtungen (Zeilen, engl.: rows) im Datensatz ausgeben zu lassen:
``` {r exercise_07pipe, exercise = TRUE}
# Hier Euer Code!
```

```{r exercise_07pipe-solution}
# Berechnung der Zeilenanzahl
data_raw %>%
  nrow()
```

```{r exercise_07pipe-check}
grade_this_code()
```
<br>

## **Quiz** 
```{r 07quiz_datenbereinigung1}
quiz(caption = NULL,
  question("Was macht einen Datensatz tidy?",
    answer("Jede Variable hat eine eigene Spalte", correct = TRUE),
    answer("Jede Beobachtung hat eine eigene Zeile", correct = TRUE),
    answer("Jeder Wert hat eine eigene Zelle", correct = TRUE),
    correct = "Richtig, bei einem "tidy" Datensatz sprechen wir auch von einem "aufgeräumten" Datensatz. Das Chaos, das möglicherweise einmal geherrscht hat ist beseitigt und es herrscht Ordnung: eine Variable von Spalte, eine Beobachtung pro Zeile und ein Wert pro Zelle!",
    incorrect = "Leider falsch, bei einem "tidy" Datensatz sprechen wir auch von einem "aufgeräumten" Datensatz. Was könnte man darunter verstehen? Versuche es nochmal oder schaue im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  ),

  question("Was ist der Pipe-Operator (%>%)?",
    answer("Eine Funktion", correct = TRUE),
    answer("Ein Werkzeug zur Strukturierung von mehrfachen Operationen in R", correct = TRUE),
    answer("Ein Werkzeug zur verbesserten Lesbarkeit von Code in R", correct = TRUE),
    answer("Syntax des ggplot2-Packages"),
    answer("Eine Besonderheit des dplyr-Packages", correct = TRUE),
    correct = "Richtig, der Pipe-Operator ist eine kleine Sache, die eine große Wirkung zeigt und uns das Leben sehr viel leichter macht! Mit diesem Ausdruck können wir verschiedene Funktionen miteinander verknüpfen. Dadurch werden unsere Daten automatisch durch diese Funktionen geleitet, wodurch unser Code deutlich strukturierter und lesbarer wird.",
    incorrect = "Leider falsch, versuche es nochmal oder schaue im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  ),

question("Wofür steht NA?",
    answer("Not accessible"),
    answer("Not available", correct = TRUE),
    answer("Not attainable"),
    correct = "Richtig, NA steht für not available (nicht verfügbar)!",
    incorrect = "Leider falsch, NA steht für not available (nicht verfügbar).",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```
<br>

# **Interaktive Übung**

Springen wir direkt weiter in unsere praktische Übung und schauen uns an, welche verschiedenen Operationen mit unseren Daten so möglich sind. Einige der Funktionen kennen wir sogar bereits!

## **1. Schritt: Import der Rohdaten**

Wie immer starten wir damit, unseren Datensatz zu laden. Hier ziehen wir uns über den Hyperlink einen ziemlich unordentlichen Rohdatensatz, aus dem wir gemeinsam zwei bereinigte Datentabellen (`community` und `audit`) generieren.

``` {r 07load_data, exercise = TRUE}
# Laden des Datensatzes
data_raw <- rio::import('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-26/plastics.csv')
```

## **2. Schritt: Definition der Bereinigungsschritte**

Nachdem wir unsere Daten erfolgreich importiert haben, können wir einen ersten Blick in den Datensatz werfen: Sieht ganz schön unordentlich aus oder? Um ein bisschen Ordnung in das Chaos zu bringen, müssen wir die Daten bereinigen. Bevor wir aber wild drauf los coden, überlegen wir uns erst einmal, welche Informationen am Ende des Bereinigungsprozesses existieren sollen und wie wir dieses Ziel erreichen.

*Hinweis: Unser Rohdatensatz enthält Daten aus den Jahren 2019 und 2020. Da wir uns an dieser Stelle erst einmal mit den grundlegenden Funktionen beschäftigen und keinen komplexen Zeitvergleich durchführen wollen, werden wir uns auf die Daten aus dem Jahr 2019 beschränken. Aufgrund der Covid-19-Pandemie stehen für das Jahr 2020 außerdem auch nur sehr wenige Daten zur Verfügung.*

Einerseits interessieren wir uns für Daten (aus dem Jahr 2019), die die #Breakfreefromplastic-Community betreffen. Wir möchten nämlich das Verhalten der Community in den verschiedenen Ländern vergleichen. Daher erstellen wir einen Datensatz  **`community`** in dem jedes Land eine Beobachtung bildet (= jede Zeile steht für ein Land). Als relevante "communitybezogene" Variablen identifizieren wir **Kontinent, Land, Countrycode, Anzahl Plastikteile, Events und Freiwillige**. Diese werden in unseren Spalten abgetragen, schließlich interessieren wir uns unter anderem dafür, wie viele Events in den verschiedenen Ländern stattgefunden haben oder wie viele Plastikteile jeweils gesammelt werden konnten.
Andererseits interessieren wir uns auch für Daten (aus dem Jahr 2019), die die Firmen betreffen, die für den Plastikmüll verantwortlich sind und die wir somit einer Prüfung (engl. Audit) unterziehen. Daher erstellen wir einen zweiten Datensatz mit dem Namen **`audit`**. Weil wir uns neben der herstellenden Firma auch für die Art des Plastikmülls (Plastiktyp) und das Land interessieren, in dem der Müll gefunden wurde bildet **Jede Zeile eine einzigartige Kombination aus Hersteller und Plastiktyp pro Land**. Als "auditbezogene" Daten identifizieren wir folgende Variablen: **Kontinent, Land, Countrycode, Hersteller, Anzahl Plastikstücke**. Diese werden in unseren Spalten abgetragen.

Folgende Datensätze wollen wir also am Ende dieser Session erstellen:
- Datensatz `community`:
  - Eine Zeile = Ein Land
  - Variablen: Kontinent, Land, Countrycode, Anzahl Plastikstücke, Events und Freiwillige
- Datensatz `audit`:
  - Eine Zeile = Eine einzigartige Kombination aus Hersteller und Plastiktyp pro Land
  - Variablen: Kontinent, Land, Countrycode, Hersteller, Anzahl Plastikstücke

Unser Ziel ist nun also klar definiert. Nun müssen wir uns überlegen, wie wir dieses Ziel erreichen können. Zum einen wollen wir natürlich ausschließlich "vollständige" Daten betrachten, d.h. Fälle, in denen zum Beispiel kein Land angegeben ist ("EMPTY") sortieren wir aus - ebenso Beobachtungen aus dem Jahr 2020 (s. Hinweis). Auch die Ländernamen müssen wir bearbeiten, da diese nicht immer einheitlich angegeben wurden (z.B. ECUADOR, Ecuador) - manche Namen müssen wir auch zunächst übersetzen (z.B. Cote D_ivoire). Abschließend müssen wir die "community- bzw- auditbezogenen" Variablen auswählen und den Datensatz entsprechend umformen. Wir entscheiden und also für folgendes Vorgehen:

  1. Zeilen, in denen das Land "EMPTY" ist, Sammelzeilen und Beobachtungen aus dem Jahr 2020 aussortieren. <br>
  2. Ländernamen bereinigen und übersetzen. <br>
  3. Entsprechende Variablen auswählen und ggf. Datensatz umformen. <br>

## **3. Schritt: Die Datenbereinigung mit dem `dplyr´-Package**

Um die Basics der Datenbereinigung kennenzulernen, werden wir in dieser Woche vor allem das **`dplyr`**-Package verwenden. Dieses ist speziell für die Datenmanipulation entwickelt worden und liefert uns eine Reihe an Möglichkeiten, um unsere Daten zu verändern. An dieser Stelle wollen wir uns einmal die **sechs Grundverben** dieses Packages anschauen.

Hier eine kurze Übersicht über die Funktionen:

| Funktion             | Wofür?                                                                                                                    |
|:----------------|:--------------------------------------------------------|
| `dplyr::filter()`    | **Auswahl von Zeilen** bzw. Beobachtungen nach bestimmten Kriterien                                                       |
| `dplyr::mutate()`    | **Erstellung neuer Spalten/Variablen** auf Basis bereits vorhandener Spalten/Variablen bzw. **Veränderung von Variablen** 
       |
| `dplyr::group_by()`  | **Gruppierung** von Beobachtungen                                                                                         |
| `dplyr::summarise()` | **Zusammenfassen** von Beobachtungen mit statistischen Kennzahlen                                                         |
| `dplyr::select()`    | **Auswahl von Spalten** bzw. Variablen                                                                                    |
| `dplyr::arrange()`   | **Sortierung** von Zeilen im Datensatz nach bestimmten Kriterien                                                          |
<br>

### **Die `filter()`-Funktion**

![Graphische Veranschaulichung der filter()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/filter.png?raw=true){#id .class width=60% height=60%}

Beginnen wir also einmal mit der Funktion **`dplyr::filter()`** mit der wir - wie der Name bereits vermuten lässt - **Zeilen bzw. Beobachtungen filtern** können. Wir betrachten also zunächst den gesamten Datensatz und lesen dann mithilfe der Funktion die Zeilen aus, die wir behalten wolllen. Dazu definieren wir bestimmte Bedingung(en), die die entsprechenden Zeilen erfüllen müssen. Die Grammatik, um diese Bedingungen festzulegen, haben wir bereits in der Session "Einführung in (R)Studio" unter dem Namen **"Kontrollstrukturen"** kennengelernt - vielleicht erinnert Ihr Euch. Wir schauen uns das Ganze aber auch direkt einmal an einem Beispiel an.

Da wir für die Analyse des Datensatzes einen **Ländervergleich** planen, wollen wir alle Beobachtungen aussortieren, für die kein Land hinterlegt wurde. Wenn kein Land hinterlegt ist, ist die Zeile `country` leer. Dafür formulieren wir folgende Bedingung: `country != "EMPTY"` *(Sprich: Die Spalte 'country' darf NICHT leer sein)*. In manchen Fällen wurden außerdem die Firmen, die für den Plasikmüll verantwortlich sind "aufsummiert" bzw. vermischt. In diesen Fällen wird in der Zeile `parent_company` der Wert "Grand Total" angegeben. Um diese Fälle ebenfalls auszusortieren formulieren wir die zweite Bedingung `parent_company != "Grand Total"` *(Sprich: Die Spalte 'parent_company' darf NICHT den Wert 'Grand Total' haben)*. Entsprechend sieht unser Code wie folgt aus:

``` {r 07overview_data, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..filtert "EMPTY" und "Grand Total" heraus
  dplyr::filter(country != "EMPTY",
                parent_company != "Grand Total")
```

Der erste Schritt ist geschafft! Wie bereits erwähnt, müssen wir aufgrund der Covid-19-Pandemie auch die Daten für das Jahr 2020 von unseren Analysen ausschließen, da diese unsere Ergebnisse verfälschen würden. Versucht das doch einmal selbst und ergänzt dazu den oberen Code um die entsprechende Bedingung:

``` {r exercise_07filter_data_exercise, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..filtert "EMPTY", "Grand Total" und alle Jahre außer 2019 heraus
  dplyr::filter(country != "EMPTY",
                parent_company != "Grand Total", 
                # Hier Euer Code! 
                )
```

```{r exercise_07filter_data_exercise-solution}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..filtert "EMPTY", "Grand Total" und alle Jahre außer 2019 heraus
  dplyr::filter(country != "EMPTY",
                parent_company != "Grand Total", 
                year == 2019 
                )
```

```{r exercise_07filter_data_exercise-check}
grade_this_code()
```

<br>

### **Die `mutate()`-Funktion**

![Graphische Veranschaulichung der mutate()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/mutate.png?raw=true){#id .class width=60% height=60%}

Nun wollen wir die die Variable `country` (zu dt. Land) bereinigen. Denn es herrscht wieder einmal Unordnung: Die Länderbezeichnungen für Großbritannien und die USA sind nicht standardisiert, die Groß- und Kleinschreibung ist vollkommen durcheinander und außerdem wollen wir die deutschen Bezeichnungen verwenden, sowie Kontinent und Countrycode ergänzen. Klingt nach sehr viel Arbeit, aber zum Glück bietet uns das `dplyr`-Package mit der Funktion **`mutate`** die Möglichkeit, Berechnungen auf Spaltenebene durchzuführen. Oder einfach gesagt: Wir können unserem Datensatz neue Variablen hinzufügen oder bestehende Variablen bearbeiten. Die grundlegende Syntax folgt folgender Logik: `dplyr::mutate(name_der_neuen_spalte = bedingung1 + bedingung2 + ...)`.

In diesem fall brauchen wir allerdings noch zwei weitere Funktionen, die wir mit der `mutate()`-Funktion kombinieren können. Zunächst einmal möchten wir die Ländernamen vereinheitlichen ("United Kingdom" und "United States"). Dafür verwenden wir die Funktion **`case_when()`** aus dem `dplyr` Package. Mit dieser Funktion können wir bestimmte Werte in einen anderen Wert transformieren - das Einzige, was wir dafür festlegen müssen, ist die entsprechende Wenn-Dann-Bedingung. Beispiel: `dplyr::case_when(country == "United Kingdom of Great Britain & Northern Ireland" ~ "United Kingdom", TRUE ~ country).
*(Sprich: Wenn (`dplyr::case_when()`) die Ländervariable `country == ...` den Wert `"United Kingdom of Great Britain & Northern Ireland"` hat, dann (`~`) erzeuge daraus den Wert `"United Kingdom"`. Dann füge diesen Wert der Variable "country" hinzu (`TRUE ~ country`)).*

In einem zweiten Schritt bedienen wir uns am Package **`stringr`**, das ebenfalls im Tidyverse enthalten ist und uns dabei hilft, Zeichenketten (engl. Strings) relativ einfach zu manipulieren und analysieren. Mit der darin enthaltenen Funktion **`str_to_title()`** wird nämlich ein "Titel" erzeugt, d.h. der Anfangsbuchstabe wird großgeschrieben. Mithilfe des Packages **`countrycode`** können wir außerdem nun die deutschen Bezeichnungen verwenden, da es uns das Übersetzen und Kodieren der Ländernamen ermöglicht.

Wichtig: Welche Funktionen Ihr am Ende für Eure Bereinigungsschritte braucht, hängt auch immer vom Datensatz ab. Gerade am Anfang kann das etwas unübersichtlich werden - vor allem mit den verschiedenen Funktionen aus unterschiedlichen Packages. Keine Sorge, mit etwas mehr Erfahrung und einer Googlerecherche lassen sich für die meisten Herausforderungen wirklich tolle Hilfsmittel finden!*

Nun wollen wir das Ganze aber auch selbst einmal ausprobieren! Der Code ist bereits schon geschrieben, allerdings fehlen an manchen Stellen (gekennzeichnet durch: ???) Funktionen und Variablennamen. Ergänzt diese an den entsprechenden Stellen, um alle Stellen zu finden, müsst Ihr etwas scrollen.

```{r exercise_07mutate_data_exercise, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..filtert "EMPTY", "Grand Total" und Jahr 2020 heraus
  dplyr::???(
    country != "EMPTY",
    parent_company != "Grand Total",
    year == 2019
    ) %>%
  # ..bereinigt die Ländernamen, indem Ihr...
  dplyr::???(
    # ..die UK und USA umbenennt
    country =
      dplyr::case_when(
        country == "United Kingdom of Great Britain & Northern Ireland" ~ "United Kingdom",
        country == "United States of America" ~ "United States",
        TRUE ~ country # falls keine der beiden Zeilen zutrifft, dann nehmen wir diese Zeile und schreiben wieder den Wert aus `country` in die neue Variable
      ),
    # ..nur den Anfangsbuchstaben der Länder großschreibt
    ??? = stringr::str_to_title(country),
    # ..Kontinent und Land übersetzt
    continent = countrycode::countrycode(country,
                                         origin = "country.name",
                                         destination = "continent"),
    ??? = dplyr::case_when(continent == "Africa" ~ "Afrika",
                                 continent == "Americas" ~ "Amerika",
                                 continent == "Asia" ~ "Asien",
                                 continent == "Europe" ~ "Europa",
                                 continent == "Oceania" ~ "Ozeanien"),
    countrycode = countrycode::countrycode(country,
                                           origin = "country.name",
                                           destination = "iso3c"),
    country = countrycode::countrycode(country,
                                           origin = "country.name",
                                           destination = "country.name.de")
    ) 
```

```{r exercise_07mutate_data_exercise-solution}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..filtert "EMPTY", "Grand Total" und Jahr 2020 heraus
  dplyr::filter(
    country != "EMPTY",
    parent_company != "Grand Total",
    year == 2019
    ) %>%
  # ..bereinigt die Ländernamen, indem Ihr...
  dplyr::mutate(
    # ..die UK und USA umbenennt
    country =
      dplyr::case_when(
        country == "United Kingdom of Great Britain & Northern Ireland" ~ "United Kingdom",
        country == "United States of America" ~ "United States",
        TRUE ~ country
      ),
    # ..nur den Anfangsbuchstaben der Länder großschreibt
    country = stringr::str_to_title(country),
    # ..Kontinent und Land übersetzt
    continent = countrycode::countrycode(country,
                                         origin = "country.name",
                                         destination = "continent"),
    continent = dplyr::case_when(continent == "Africa" ~ "Afrika",
                                 continent == "Americas" ~ "Amerika",
                                 continent == "Asia" ~ "Asien",
                                 continent == "Europe" ~ "Europa",
                                 continent == "Oceania" ~ "Ozeanien"),
    countrycode = countrycode::countrycode(country,
                                           origin = "country.name",
                                           destination = "iso3c"),
    country = countrycode::countrycode(country,
                                           origin = "country.name",
                                           destination = "country.name.de")
    ) 
```

```{r exercise_07mutate_data_exercise-check}
grade_this_code()
```

Ein Großteil unserer Datenbereinigung ist nun abgeschlossen - das Ergebnis steht Euch unter `plastics_processed` zur Verfügung! Da wir uns einerseits für community- und andererseits für auditbezogene Daten interessieren, können wir uns nun anschauen, wie wir den Datensatz in zwei Tabellen afteilen.

### **Die `group_by()`- und `summarise()`-Funktion**

![Graphische Veranschaulichung der group_by()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/groupby.png?raw=true){#id .class width=60% height=60%}
![Graphische Veranschaulichung der summarise()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/summarize.png?raw=true){#id .class width=60% height=60%}

Nach wie vor verfolgen wir mit unserer Datenbereinigung das Ziel der **Ländervergleiche**: Wir möchten herausfinden, in welchen Ländern die meisten Plastikteile gesammelt und die meisten Events durchgeführt wurden oder wo die meisten Freiwilligen aktiv sind. Dazu müssen wir innerhalb des `community` Datensatzes eine Struktur erschaffen, in dem eine Beobachtung pro Land vorhanden ist - wir müssen unsere bereinigten Daten also pro Land **gruppieren**. Denn aktuell gibt es für die meisten Länder unzählige verschiedene Beobachtungen, wodurch diese länderübergreifenden Vergleiche (noch) nicht möglich sind. 

Um unserem Ziel näher zu kommen greifen wir auf zwei weitere Funktionen aus dem `dplyr` zurück, die und häufig miteinander kombiniert werden: Die Funktionen **`group_by()`** und **`summarise()`** (auch: `summarize()`). Zusammen sind sie besonders nützlich für das Erstellen von Gruppenzusammenfassungen und die Berechnung von Statistiken für verschiedene Kategorien innerhalb eines Datensatzes. 
Die Funktion **`group_by()`** wird dabei  verwendet, um Daten nach einer oder mehreren Variablen zu gruppieren, wodurch wir im Anschluss Berechnungen oder Zusammenfassungen auf Gruppenebene durchführen können. Die **`summarise()`**-Funktion  (oder: `summarize()`) kennen wir bereits. In Kombination mit der `group_by()`-Funktion können wir die gewohnten zusammenfassenden Statistiken oder Berechnungen nun für jede Gruppe im Datensatz erstellen.
In der Praxis gruppieren wir also zuerst entsprechend der Kontinente und Länder (`dplyr::group_by(continent, country, countrycode)`). Anschließend müssen wir ebenfalls entscheiden, wie die anderen Variablen zusammengefasst werden (`dplyr::summarise(…)`). In diesem Fall addieren wir die Plastikteile und wählen für die Anzahl der Events und Freiwilligen genau einen Wert aus. Diese sind im Originaldatensatz mehrfach vorhanden - etwas, das typischerweise beim Zusammenfügen von Datensätzen entsteht. Aber schauen wir uns das ganze Vorgehen doch einmal direkt in unserem R-Code an:

``` {r 07group_by_summarise1, exercise = TRUE}
# Ihr nehmt Euren Datensatz, ...
community <- plastics_processed %>% 
  # … gruppiert die Beobachtungen pro Land
  dplyr::group_by(continent, country, countrycode) %>% # Pro Kontinent und Land gruppieren
  # … entscheidet, wie die anderen Variablen zusammengefasst werden sollen
  dplyr::summarise(
    n_pieces = sum(grand_total, na.rm = TRUE), # Summe
    n_volunteers = unique(volunteers), # Einzigartige Werte (da Duplikate)
    n_events = unique(num_events) # Einzigartige Werte (da Duplikate)
  )
```

Und jetzt Ihr: Verwendet an dieser Stelle die neuen Funktionen `dplyr::group_by()` und `dplyr::summarise()` und versucht einmal die Gesamtzahl der Plastikstücke, die pro Kontinent gesammelt wurden zu berechnen - nutzt dafür den `community`-Datensatz.

```{r 07group_by_summarise2, exercise = TRUE}
# Hier Euer Code
```

```{r 07group_by_summarise2-solution}
# Ihr nehmt Euren Datensatz, ...
community %>%
  # … gruppiert die Beobachtungen pro Kontinent
  dplyr::group_by(continent) %>%
  # … entscheidet, wie die anderen Variablen zusammengefasst werden sollen
  dplyr::summarise(n_pieces = sum(n_pieces, na.rm = TRUE)) # Summe
```

```{r 07group_by_summarise2-check}
grade_this_code()
```

## **Die `select()`-Funktion**
![Graphische Veranschaulichung der select()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/select.png?raw=true){#id .class width=60% height=60%}

Bislang haben wir Zeilen bzw. Beobachtungen gefiltert, aber dabei soll es nicht bleiben. Denn das `dplyr` liefert uns glücklicherweise auch direkt eine Funktion, mit der wir auch **Spalten bzw. Variablen filtern** können: Die **`select()`**-Funktion. Sie ist also ein durchaus hilfreiches Werkzeug, weil sie es ermöglicht, den Datensatz auf die **relevanten Spalten zu reduzieren**. Wir können einerseits bestimmte Spalten auswählen, aber auch Spalten umbenennen und nach verschiedenen Kriterien auswählen, wie z. B. nach dem Namen, dem Typ oder der Position der Spalten. Dabei können wir entweder die Variablen auswählen, die im Datensatz enthalten bleiben sollen oder aber mit einem `-` die Variablen auswählen, die aus Eurem Datensatz gelöscht werden sollen. Der folgende Code löscht so zum Beispiel die Variable `grand_total` aus dem `data_raw`-Datensatz:

``` {r 07select_data1, exercise = TRUE}
# Spalte "grand_total" NICHT auswählen
data_raw %>%
  dplyr::select(-grand_total) %>%
  head()
```

Um die Bereinigung des `audit`-Datensatzes zu finalisieren, wählen wir also in einem letzten Schritt noch alle relevanten Variablen aus:

```{r 07select_data2, exercise = TRUE}
  # Ihr nehmt Euren Datensatz ...
audit <- plastics_processed %>%
  # …pivotiert die Plastikarten
  tidyr::pivot_longer(
    cols = c(hdpe, ldpe, o, pet, pp, ps, pvc), # Betroffene Variablen
    names_to = "plastic_type",                 # Zielspalte
    values_to = "n_pieces"                     # Wertspalte
    names_to = "plastic_type", 	               # Zielspalte
    values_to = "n_pieces" 		                 # Wertspalte
    ) %>%
  # … faktorisiert sicherheitshalber die anderen Variablen (nicht immer notwendig)
  dplyr::mutate(dplyr::across( # Zu Faktor konvertieren
    .cols = c(country, continent, countrycode, year, plastic_type),
    .fns = as_factor
    )) %>%
  # … und wählt die richtigen Spalten aus, da manche Variablen mit der Pivotierung nicht aussagekräftig sind.
  dplyr::select(continent, country, countrycode, parent_company, plastic_type, n_pieces)
```

Schon ist ein großer Schritt getan und unsere beiden Datensätze sind bereinigt! Was meint Ihr: Sind die enthaltenen Werte richtig? Können wir diese Frage überhaupt einfach so beantworten? Schwierig, das auf den ersten Blick zu sagen - aber wir können mit R eine Art **Qualitätsprüfung** durchführen. Schauen wir uns also für beide Datensätze einige Informationen an:

```{r sanitycheck, exercise = TRUE}
# Anzahl Plastikstücke
sum(community$n_pieces, na.rm = TRUE) == sum(plastics_processed$grand_total)
sum(audit$n_pieces, na.rm = TRUE) == sum(plastics_processed$grand_total)
# Länder
sort(unique(community$country)) == sort(unique(audit$country))
```

Das sieht doch sauber aus - gut gemacht!

<br>

## **Die `arrange()`-Funktion**
![Graphische Veranschaulichung der arrange()-Funktion](https://github.com/CorrelAid/rlernen_umwelt/blob/main/abbildungen/07_datentransformation/arrange.png?raw=true){#id .class width=60% height=60%}

Unsere Daten sind erst einmal bereinigt und das ist ein riesiger Schritt, häufig ist die Bereinigung nämlich deutlich mehr Arbeit als die anschließenden Visualisierungen oder Berechnungen - Ihr könnt also wirklich stolz auf Euch sein! 
Und dennoch sind wir noch nicht ganz fertig mit den `dplyr`-Package. Denn das hat einfach unglaublich viel zu bieten. Eine Funktion, die wir Euch definitiv nicht vorenthalten möchten ist die **`arrange()`**-Funktion. Diese wird eher für die Transformation unserer Daten als für deren Bereinigung genutzt. Mit dieser Funktion kann man die Zeilen eines Datensatzes nach den Werten einer oder mehrerer Spalten sortieren bzw. **Ranglisten ausgeben**. Sie ist also eine große Hilfe, wenn wir Daten in einer bestimmten Reihenfolge analysieren und präsentieren oder für Berichte vorbereiten möchten. Wenn wir uns also für die „Top 10“ der Firmen interessieren, die am meisten Plastikmüll produzieren, können wir zunächst alle Firmen auswählen und gruppieren, uns eine Zusammenfassung ausgeben lassen und dann auf die „Top 10“ beschränken. Anschließend können wir mit `dplyr::arrange()` die Werte in absteigender Reihenfolge sortieren:

```{r arrange, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
audit %>%
  # ..wählt relevante Spalten aus
  dplyr::select(parent_company, n_pieces) %>%
  # ..gruppiert pro Hersteller
  dplyr::group_by(parent_company) %>%
  # ..berechnet die Zusammenfassung (hier: Summe)
  dplyr::summarise(total_pieces = sum(n_pieces, na.rm = TRUE)) %>%
  # ..filtert unnütze Werte heraus
  dplyr::filter(! parent_company %in% c("Unbranded", "Inconnu", "Assorted"))  %>%
  # ..begrenzt die Anzahl auf 10
  dplyr::slice_max(total_pieces, n = 10) %>%
  # ..und sortiert die Werte absteigend
  dplyr::arrange(desc(total_pieces))
```

Nun können wir das gefundene Plastik den verschiedenen Firmen zuordnen: LaDoo, Coca-Cola und Barna sind dabei offensichtlich die drei Firmen, die mit 15.221, 9.988 bzw. 6.225 gefundenen Plastikteilen in hohem Maße für die Umweltverschmutzung durch Plastikmüll verantwortlich sind. Diese Ergebnisse könnten wir nun vielleicht für unsere nächste Kampagne verwenden oder was meint Ihr?

Nun sind wir aber wirklich durch. Ihr kennt alle `dplyr`-Verben und seid fit für die Datentransformation! Mit dem neuen Wissen können wir direkt in die Übungsaufgabe einsteigen und nochmal alles ausprobieren. Vorher aber noch einmal ein kleiner Hinweis: Auf einige Themen sind wir hier nur am Rande eingegangen, allerdings werden wir uns einige davon (z.B. den Umgang mit fehlenden Werte (NAs, die Umformung von Textdaten und das Zusammenfügen von Datensätzen) bereits in der kommenden Woche im Detail anschauen. Lasst Euch also davon nicht beirren!

# **Und jetzt Ihr**

Wenn Ihr einen **eigenen Datensatz** habt - den Ihr letzte Woche bereits in R importiert habt - dann könnt Ihr jetzt versuchen, diesen zu bereinigen. Wenn Ihr nicht genug von Datenbereinigung bekommen könnt oder Ihr keinen eigenen Datensatz habt, dann schaut Euch das **R Markdown: 06_datentransformation-uebung.Rmd** (im [Übungsordner](https://download-directory.github.io/?url=https://github.com/CorrelAid/rlernen_umwelt/tree/main/uebungen){target="_blank"} unter 06_datentransformation) an und versucht die Aufgaben darin zu bearbeiten. 

# **Zusätzliche Ressourcen**

- [Schummelblatt: dplyr](https://github.com/CorrelAid/lernplattform/blob/main/cheatsheets/06_cheatsheet-dplyr.pdf){target="_blank"} (engl.)
- [Schummelblatt: stringr](https://github.com/CorrelAid/lernplattform/blob/main/cheatsheets/06_cheatsheet-stringr.pdf){target="_blank"} (engl.)
- [Schummelblatt: tidyr](https://github.com/CorrelAid/lernplattform/blob/main/cheatsheets/06_cheatsheet-tidyr.pdf){target="_blank"} (engl.)
- [Data Cleaning in R](https://app.dataquest.io/course/r-data-cleaning){target="_blank"} auf DataQuest (engl.)
- [Advanced Data Cleaning in R](https://app.dataquest.io/course/r-data-cleaning-advanced){target="_blank"} auf DataQuest (engl.)
- Ein noch etwas holpriger Spielplatz, der zeigt, wie Eure Schritte in der Datenbereinigung aussehen: [Tidy Data Tutor](https://tidydatatutor.com){target="_blank"} (engl.)
- [Tidyverse: Tidy data](https://tidyr.tidyverse.org/articles/tidy-data.html){target="_blank"} (engl.)

<a class="btn btn-primary btn-back-to-main" href=`r params$links$end_session`>Session beenden</a>

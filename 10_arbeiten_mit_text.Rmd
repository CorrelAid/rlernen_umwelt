---
title: "Arbeiten mit Text"
author: CorrelAid e.V.
date: "`r Sys.Date()`"
authors:
  - Alexandros Melemenidis
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: flatly
    css: www/style.css
    includes:
      after_body: ./www/favicon.html
    language: de
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(learnr)
library(gradethis)
 
source("R/setup/gradethis-setup.R")
source("R/setup/tutorial-setup.R")
# Read app parameters
params <- yaml::yaml.load_file("www/app_parameters.yml")

# Benötigte Daten laden
source("R/setup/functions.R")

basis_url <- "https://unstats.un.org/"
initiale_anfrage <- get_initiale_anfrage(url = basis_url)
waste_data <- get_waste_data(anfrage = initiale_anfrage)
pages <- get_pages(content = waste_data)
```

```{r results='asis'}
cat(get_license_note(rmarkdown::metadata$title, rmarkdown::metadata$authors))
```

![*Video: Arbeiten mit Text (20min)*](https://youtu.be/NOHyED9u3x0)

# **Das stringr-Package**

<left>

![](https://www.tidyverse.org/css/images/hex/stringr.png){#id .class width="20%" height="100%"}

</left> <br>

## **Zusammenfassung**

- Textdaten, können in verschiedenen Formen vorliegen - als **kategoriale Variablen**, **falsch eingelesene numerische Daten**, **kombinierte Variablen aus Text und Zahl** oder **komplexe, lange Texte**. 
- Zur Verarbeitung von Textdaten in R verwenden wir das **`stringr`-Package**.
- `stringr` ist ein Package mit einer konsistenten Syntax für die **Arbeit mit Zeichenketten (engl. Strings)**.
- Als **Teil des Tidyverse** lassen sich die Funktionen gut mit den dplyr-Verben kombinieren.
- Alle Funktionen **beginnen mit `str_`**, was die Anwendung erleichtert und konsistent macht.
- **Regex (reguläre Ausdrücke)** sind spezielle Muster, die verwendet werden, um Text zu suchen, zu überprüfen und zu manipulieren, indem sie komplexe Bedingungen für die Übereinstimmung von Zeichenfolgen definieren.

## **Die wichtigsten Funktionen von stringr**

Das `stringr`-Package enthält viele verschiedene Funktionen, die wir mit anderem Funktionen des tidyverse kombinieren können (z.B. mit den Verben des `dplyr`-Packages). Das sind die wichtigsten Funktionen des `stringr`:

<style>
table {
  width: 100%;
}
th {
  text-align: left;  /* Linksbündige Ausrichtung der Überschriften */
}
</style>

| Funktion                         | Verwendung                                                        |
|----------------------------------|-------------------------------------------------------------------|
| `stringr::str_to_upper()`       | Wandelt alle Zeichen in einer Zeichenkette in Großbuchstaben um.  |
| `stringr::str_to_lower()`       | Wandelt alle Zeichen in einer Zeichenkette in Kleinbuchstaben um. |
| `stringr::str_to_title()`       | Wandelt den ersten Buchstaben jedes Wortes in einer Zeichenkette in Großbuchstaben um. |
| `stringr::str_sub()`            | Extrahiert einen Teil einer Zeichenkette basierend auf Start- und Endposition. |
| `stringr::str_detect()`         | Überprüft, ob eine bestimmte Zeichenfolge in einer Zeichenkette vorhanden ist (gibt TRUE oder FALSE zurück). |
| `stringr::str_match()`          | Findet Übereinstimmungen mit einem regulären Ausdruck und gibt die gefundene Übereinstimmung zurück. |
| `stringr::str_extract()`        | Extrahiert die erste Übereinstimmung eines regulären Ausdrucks aus einer Zeichenkette. |
| `stringr::str_replace()`        | Ersetzt die erste Übereinstimmung eines regulären Ausdrucks durch eine neue Zeichenkette. |
| `stringr::str_length()`         | Gibt die Länge einer Zeichenkette zurück (Anzahl der Zeichen).     |

## **Quiz**

```{r 15quiz_arbeiten_mit_text1}
quiz(caption = NULL,
  question("Bei welchen Daten handelt es sich tatsächlich um Textdaten?",
    answer("Namen von Personen, Städten, etc. (z. B. 'Laura', 'Berlin')", correct = TRUE),
    answer("Alter in Jahren (z. B. 28, 34)", correct = FALSE),
    answer("Postleitzahlen (z. B. '04109', '80331')", correct = TRUE),
    answer("Umsatz in Euro (z. B. 2500, 4500)", correct = FALSE),
    answer("Produktbeschreibungen (z. B. 'Hochwertiger Laptop')", correct = TRUE),
    answer("Durchschnittstemperatur in °C (z. B. 22.5)", correct = FALSE),
    correct = "Richtig, bei normalem Text in Form von Produktbeschreibungen und Namen handelt es sich logischerweise um Textdaten! Aufgrund ihrer Formatierung (z.B. '04109' = Leipzig Stadtmitte) werden Postleitzahlen allerdings auch häufig als Textdaten gelesen. Da die anfängliche 0 bei numerischen Variablen verloren gehen würde, wählt man häufig die Codierung in Textform.",
    incorrect = "Leider falsch, versuche es noch einmal. Überlege Dir, welche Daten ausschließlich in Form von Text bzw. ausschließlich in Form von Zahlen vorliegen. Bei welcher Antwortmöglichkeit könnte es womöglich etwas komplizierter sein?",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
    ),
     
  question("Wozu dient die Funktion `str_length()`?",
    answer("Zum Zählen der Zeichenanzahl eines Texts.", correct = TRUE),
    answer("Zum entfernen unnötiger Leerzeichen in einem Text.", correct = FALSE),
    answer("Zur Umwandlung des texts von Klein- in Großbuchstaben.", correct = FALSE),
    answer("Zur Bestimmung der Position einer Zeichenfolge innerhalb des Textes.", correct = FALSE),
    correct = "Richtig, die Funktion `str_length()` können wir verwenden, um die Länge (engl. length) eines Textes zu bestimmen!",
    incorrect = "Leider falsch, versuche es noch einmal oder schaue oben in der Übersicht nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  ),
  

  question("Welche Funktion verwenden wir, um sicherzustellen, dass der erste Buchstabe einer Zeichenkette groß geschrieben wird?",
    answer("str_to_lower()", correct = FALSE),
    answer("str_to_title()", correct = TRUE),  
    answer("str_to_upper()", correct = FALSE),
    answer("str_sub()", correct = FALSE),
    correct = "Richtig, die Funktion str_to_title() sorgt dafür, dass der erste Buchstabe in jedem Wort groß geschrieben wird! Somit können wir Namen von Personen, Städten oder eben Ländern in ein einheitliches Format bringen.",
    incorrect = "Leider falsch, versuche es noch einmal oder schaue oben in der Übersicht nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  ),
  
  question("Was ist ein regulärer Ausdruck (Regex)?",
    answer("Ein Werkzeug, um Textvariablen in numerische Variablen umzuwandeln.", correct = FALSE),
    answer("Eine Methode, um Muster in Texten zu finden oder zu beschreiben.", correct = TRUE),
    answer("Eine Funktion, die im stringr enthalten ist.", correct = FALSE),
    answer("Eine zufällige Aneinanderreihung von Symbolen.", correct = FALSE),
    correct = "Richtig, bei der Arbeit mit Textdaten können uns die regulären Ausdrücke (Regex's) eine große Hilfe sein. Wir können diese Methode nutzen, um Muster in Texten zu finden oder zu beschreiben.",
    incorrect = "Leider falsch, versuche es einfach nochmal oder schaue im Video nach.",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  ),
  
  question("Welcher reguläre Ausdruck passt zu einer gültigen deutschen Telefonnummer im Format `01234/567890`?",
    answer("`\\d{5}/\\d{6}`", correct = TRUE),
    answer("`\\d{5}-\\d{6}`", correct = FALSE),
    answer("`\\d{5}\\d{6}`", correct = FALSE),
    answer("`\\d{5}/\\d{5}`", correct = FALSE),
    correct = "Richtig, mit dem entsprechenden Ausdruck können wir nach einer Zeichenkette suchen, die einmal aus fünf Ziffern (= '\\d{5}') und  sechs Ziffern (= '\\d{6}') besteht, die durch ein '/' gestrennt werden!",
    incorrect = "Leider falsch, versuche es einfach nochmal - an dieser Stelle muss genau gezählt werden!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

Soweit einmal der Einstieg in das `stringr`-Package. natürlich gibt es noch viele weitere spannende Funktionen und Möglichkeiten, um mit Textdaten zu arbeiten. Wenn Ihr Euch dafür interessiert, schaut doch gerne einmal in der [Dokumentation des `stringr`-Packages](https://stringr.tidyverse.org/) oder den Zusatzressourcen dieser Session nach. Für den Einstieg in das Thema werden wir uns an dieser Stelle auf einige der Grundfunktionen beschränken müssen!

---

# **Interaktive Übung**

Nachdem wir uns nun ein wenig damit vertraut gemacht haben, wie wir mit Daten arbeiten können und welche Möglichkeiten und das R dabei bietet, wollen wir das Ganze einmal selbst ausprobieren!

## **1. Schritt: Import der Rohdaten**

Wie gewohnt laden wir zu allererst unseren Datensatz. Wir werden an dieser Stelle noch einmal auf unseren Ausgangsdatensatzes `plastic` zurückgreifen. In diesem sind noch die unformatierten Rohdaten enthalten. Lasst Euch davon nicht verunsichern, denn in erster Linie soll es einmal darum gehen, die verschiedenen Funktionen kennzulernen und auszuprobieren. 

```{r 15load_data, exercise = TRUE}
# Laden des Datensatzes
plastic <- rio::import("https://raw.githubusercontent.com/CorrelAid/lernplattform/main/daten/plastics.csv")

```

## **2. Schritt: Groß- und Kleinschreibung**

### **Die `str_to_upper()`- Funktion**

In unserem Datensatz sind verschiedene Plastikarten vorhanden, diese werden von den Variablen 5-11 dargestellt. Noch werden diese Kunststoffarten in Kleinbuchstaben angegeben. Generell ist es allerdings eher üblich, diese in Großbuchstaben anzugeben, weshalb wir die Funktion **`str_to_upper()** dafür verwenden wollen, um die Variablen in Großbuchstaben umzuwandeln:

Üblicherweise werden Kunststoffsorten in Großbuchstaben angegeben, die üblicherweise in Großbuchstaben angegeben werden. Nutzen wir die Base-R Funktion `names()` um die Variablennamem aufzurufen und `stringr::str_to_upper()`, um sie in Großbuchstaben umzuwandeln.

```{r 15to_upper_beispiel, exercise = TRUE}
# Wir rufen zuerst die Spalten der entsprechenden Variablen auf. Die `names()`-Funktion ist Teil von Base-R und bereits vorinstalliert
names(plastic)[5:11] 

# Damit wir einfacher mit diesen Variablen arbeiten können, speichern wir sie in einem neuen Datensatz 'plastic_names' ab
plastic_names <- names(plastic)[5:11] 

# Nun nutzen wir die Funktion str_to_upper() aus dem stringr-Paket, um die ausgewählten Spaltennamen in Großbuchstaben umzuwandeln
plastic_names <- stringr::str_to_upper(plastic_names)

# Anschließend überprüfen wir die Änderung
table(plastic_names)
```

Das sieht doch schon ganz gut aus! Die Namen unserer Variablen enthalten ausschließlich Großbuchstaben. Wollen wir uns nun einmal anschauen, wie das für die Variable `country` funktioniert!

---

### **Die `str_to_title()`- Funktion**

Im Gegensatz zu den Variablen der Kunststoffarten, wollen wir an dieser Stelle nicht den Namen unserer Variable `country` verändern. Stattdessen wollen wir die Gelegenheit nutzen, um die Ländernamen in einem einheitlichen Format auszugeben. Bislang haben wir nämlich noch das Problem, dass diese völlig unterschiedlich angegeben sind (z.B. "Ecuador", "ECUADOR", etc.).

An dieser Stelle können wir die **`str_to_title()`**-Funktion dafür verwenden, um die Variable `country` zu vereinheitlichen. Die Funktion sorgt nämlich dafür, dass Zeichenketten einheitlich im sogenannten Title Case ausgegeben werden. Das Title Case ist eine **Textformatierung**, bei der der erste Buchstabe eines Wortes großgeschrieben wird. Wenn ein Satz mehrere Wörter enthält, werden die Anfangsbuchstaben aller Wörter groß geschrieben. Versucht das doch einmal selbst:

*Hinweis: In diesem Fall müssen wir die Funktion mutate() aus dem dplyr-Package verwenden, weil wir R damit signalisieren, dass wir eine bestehende Variable aktualisieren wollen.*

```{r exercise_15to_title, exercise = TRUE}
# Zunächst verschaffen wir uns einen Überblick über die verschiedenen Ausprägungen der Variable.
table(plastic$country)

# Anschließend nehmen wir unseren Datensatz ...
plastic <- plastic %>%  
  
# ... und transformieren die Ausprägungen unserer Variable 'country' in das Title Case
    dplyr::mutate(country = stringr::???(???))
```

```{r exercise_15to_title-solution}
# Zunächst verschaffen wir uns einen Überblick über die verschiedenen Ausprägungen der Variable.
table(plastic$country)

# Anschließend nehmen wir unseren Datensatz ...
plastic <- plastic %>%
  
# ... und transformieren die Ausprägungen unserer Variable 'country' in das Title Case.
    dplyr::mutate(country = stringr::str_to_title(country))

# Anschließend überprüfen wir unsere Veränderungen.
table(plastic$country)

```

```{r exercise_15to_title-check}
grade_this_code()
```

---

### **Die `str_replace()`- Funktion**
Als nächstes möchten wir die Namen einiger multinationaler Konzerne im Datensatz vereinfachen. Um den Code kurz und flexibel zu halten, nutzen wir hierzu `str_replace()` zusammen mit regulären Ausdrücken.

Als erstes Beispiel bearbeiten wir die Einträge von `parent_company` welche zu PepsiCo gehören. Mit dem regulären Ausdruck`'.*[Pp]epsi.*'` erfassen wir alle, Einträge die `Pepsi` oder `pepsi` und von einer unbestimmten Menge weiterer Zeichen umschlossen sind. Dies erfasst die drei folgenden im Datensatz vorhandenen Varianten:

| parent_company  |
|-----------------|
| Pepsico         |
| PepsiCo         |
| Etika - PepsiCo |

Wir wollen die gefundenen Einträge einheitlich mit dem Namen `PepsiCo` ersetzen. Die Syntax von `str_replace` funktioniert folgendermaßen: `str_replace(*Textvariable*, *Zeichenfolge oder Regex*, *Ersatz*)`

```{r 15replace_Pepsi, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
data_raw  %>%
  # ..und bearbeitet ihn mittels dplyr::mutate
  dplyr::mutate(
    #.. und ersetzt den regulären Ausdruck mittels str_replace() mit dem gewünschten Text
    parent_company = stringr::str_replace(parent_company, '.*[Pp]epsi.*', 'PepsiCo')
  )
```

Als weiteres Beispiel zur praktischen Anwendung schauen wir uns die Kraft Heinz Company an. Hierfür gibt es folgende Varianten, die einheitlich mit dem Namen `Kraft Heinz Company` ersetzt werden sollen:

| parent_company      |
|---------------------|
| Kraft Heinz Company |
| Kraft Foods         |
| kraft food          |
| Capri Sun/Kraft     |
| Kraft Suchard       |
| Kraft Heinz         |
| Kraft               |

```{r exercise_15replace_kraft_exercise, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
data_raw  %>%
  # ..und bearbeitet ihn mittels dplyr::mutate
  dplyr::mutate(
    # Hier Euer Code! 
                )
```

```{r exercise_15replace_kraft_exercise-solution}
# Ihr nehmt Euren Datensatz...
data_raw %>%
  # ..und bearbeitet ihn mittels dplyr::mutate
  dplyr::mutate(
    parent_company = stringr::str_replace(parent_company, '.*[Kk]raft.*', 'Kraft Foods')
                )
```

```{r exercise_15replace_kraft_exercise-check}
grade_this_code()
```


#### **Weitere Beispiele für Regex**

Arbeiten wir auch noch ein paar Beispiel durch, die der Plastik-Datensatz nicht hergibt, wie zum Beispiel das Erkennen von Ziffern.

```{r regex_examples, exercise = TRUE}
regex_df <- tibble::tribble(
  ~name,      ~adresse,                                  ~kfz,       ~geburtsdatum,     ~groesse, 
  "Person 1", 'Kaiserstraße 29, 60311 Frankfurt am Main', 'F-FM 101', '26.01.2001',      '1,88m', 
  "Person 2", 'Panoramastraße 1A, 10178 Berlin',          'B-BG 200', '7.7.1999',        '1,67m',
  "Person 3", 'Arnulf-Klett-Platz 2, 70173 Stuttgart',    'S-Ö 9999', '12.12.1985',      '1,92m'
  )
```

Neben `str_replace()` können auch einfachere Funktionen von stringr benutzt werden. So kann mit `str_detect()` einfach überprüft werden, ob ein regulärer Ausdruck gefunden wird oder nicht. Dies lässt sich dann auch gut mit `dplyr::filter()` verbinden, um nur die Zeilen zu übernehmen, bei denen die Regex gefunden wird.

Überprüfen wir zum Beispiel, ob die Zeichenfolgen in der Spalte `kfz` valide deutsche KFZ-Kennzeichen sind:

```{r str_detect_example, exercise = TRUE}
regex_df %>%
  dplyr::mutate(
    kfz_valide = stringr::str_detect(kfz, '[A-ZÄÖÜ]{1,3}-[A-Z0-9]{1,2} \\d{1,4}')
  )
```

Als nächstes erstellen wir als Übung eine neue Spalte `PLZ` aus den Daten der Spalte `adresse`. Hierfür nutzen wir die Funktion `str_match()` und den geeigneten regulären Ausdruck. Die Funktion hat zwei Argumente und folgende Syntax: `str_match(*Text*, *Regex/Zeichenfolge*)`

Fügt im folgenden Codeblock anstelle der `???` den korrekten Regex ein. *Um ein Backslash in einem Text an R zur Evaluierung zu schicken, muss ein weiteres Backslash davorgestellt werden!*

```{r exercise_15extract_zip_exercise, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
regex_df  %>%
  # ..und bearbeitet ihn mittels dplyr::mutate
  dplyr::mutate(
    # Hier Euer Code! 
    plz = stringr::str_match(adresse, '???')
                )
```

```{r exercise_15extract_zip_exercise-solution}
# Ihr nehmt Euren Datensatz...
regex_df %>%
  # ..und bearbeitet ihn mittels dplyr::mutate
  dplyr::mutate(
    plz = stringr::str_match(adresse, '\\d{5}')
                )
```

```{r exercise_15extract_zip_exercise-check}
grade_this_code()
```

#### **Umwandlung von Datentypen**

Alle Spalten im Beispieldatensatz sind als Textdaten formatiert, jedoch wären auch Anwendungsfälle vorstellbar, bei denen wir mit den numerischen Informationen in den Spalten `geburtsdatum` und `groesse` rechnen wollten.

Um die **Geburtsdaten** vom Text in das R-Datumsformat umzuwandeln können wir direkt mit der Funktion `dmy()` aus dem `lubridate`-Package arbeiten.

```{r 15convert_date, exercise = TRUE}
# Ihr nehmt Euren Datensatz,...
regex_df %>%
  dplyr::mutate(
    geb_numerisch = lubridate::dmy(geburtsdatum)
  )
```

Sollte eine der vorhandenen Funktionen nicht funktionieren, kann alternativ die Funktion `lubridate:as_date()` mit dem richtigen Textformat verwendet werden. Für den vorliegenden Fall aus ein-oder zweistelligen Tages- und Monatszahlen wäre das richtige Format `'%d.%m.%Y'`. Für weitere Formatoptionen schaut in der R-Dokumentation nach (`help("strptime")`).

Berechnet nun zur Übung eine Spalte `groesse_numerisch` mit den Funktionen `stringr::str_sub()`, `str_replace()` und `as.numeric()`. `str_sub()` kann Teile von Texten anhand der Zeichenposition extrahieren und hat folgende Syntax:\
`str_sub(*Text*, *Position Start*, *Position Ende*)`

```{r 15convert_numeric_exercise, exercise = TRUE}
# Ihr nehmt Euren Datensatz,...
regex_df %>%
  dplyr::mutate(
    #Hier euer Code...
    # 1. wandelt in Dezimalzahl um
    groesse_numerisch = ???(
      # 2. extrahiere die ersten vier Zeichen
      ???(
        # 3. ersetze Komma mit Punkt 
        ???(),
           ???, ???)
    )
  )
```

```{r 15convert_numeric_exercise-solution}
# Ihr nehmt Euren Datensatz,...
regex_df %>%
  dplyr::mutate(
    # 1. wandelt in Dezimalzahl um
    groesse_numerisch = as.numeric(
      # 2. extrahiere die ersten vier Zeichen
      stringr::str_sub(
        # 3. ersetze Komma mit Punkt 
        stringr::str_replace(groesse, ',', '.'), 
              1, 4)
      )
  )
```

```{r 15convert_numeric_exercise-check}
grade_this_code()
```

---

<details>
  <summary><h3>&#10145; Exkurs: Text Mining</h3></summary>
  <br>

Zur Veranschaulichung von Text Mining wollen wir nun ein deutschsprachiges Werk aus dem [Project Gutenberg](https://www.gutenberg.org/) analysieren, welche sich bequem im dem R-Package `gutenbergr` herunterladen lassen.
Als Beispiel soll hier "Dr. Oetkers Grundlehren der Kochkunst" dienen (Gutenberg ID 31537), welches wir bereits in einen Dataframe namens `oetker` bereitgestellt haben.

Zunächst möchten wir das Werk mit der Funktion `tidytext::unnnest_tokens()` in seine einzelnen Wörter zerlegen. Diese werden dabei auch standardmäßig in Kleinschreibung umgewandelt. Danach bereinigen wir den Datensatz um sogenannte Stoppwörter (mit dem Package `stopwords`), Zahlen und einzelne Buchstaben. Zuletzt zählen wir, wie häufig die einzelnen Wörter im Text vorkommen und visualisieren dies dann in einer Wordcloud (mit dem Package `wordcloud`).

```{r 15wordcloud, exercise = TRUE}
# Wir nehmen den Datensatz...
woerter <- oetker %>%
  # ...und teilen ihn in einzelne Wörter (Tokens) auf
  tidytext::unnest_tokens(wort, text)

# Deutsche Stoppwörter in "stopp" speichern
stopp <- stopwords::stopwords("de")

# Jetzt nehmen wir unsere Liste an Wörtern...
woerter <- woerter %>%
  # ...und filtern Stoppwörter,
  dplyr::filter(!(wort %in% stopp),
                # Zahlen,
                !stringr::str_detect(wort, "\\d"),
                # nicht alphanumerische Zeichen.
                !stringr::str_detect(wort, "^\\w$"))

# Wir zählen die Häufigkeit jedes Wortes...
hitlist <- woerter %>%
  dplyr::count(wort, sort = TRUE)

# ...und erstellen daraus eine Wortwolke!
wordcloud::wordcloud(hitlist$wort, hitlist$n, min.freq = 20)
```

Als zweites wollen wir schauen, ob das Kochbuch im Durchschnitt eher positive oder negative Wörter verwendet.
Den Sentimentwortschatz vom Projekt [Wortschatz Leipzig](https://wortschatz.uni-leipzig.de/de/download) haben wir dabei schon als Dataframe `lexicon` importiert.
Da der Wortschatz Wörter in Groß- und Kleinschreibung klassifiziert zerlegen wir das Buch noch einmal in seine Wörter, aber diesmal ohne die Umwandlung. So können wir den Text-Dataframe mit dem Sentimentwortschatz joinen und so allen in beiden Tabellen vorhandenen Wörtern einen Sentimentwert zuordnen. Abschließend können wir über den Durchschnitt das gesamte Sentiment bestimmen.

```{r 15sentiment, exercise = TRUE}
# Wir nehmen den Datensatz...
woerter_2 <- oetker %>%
  # ...und teilen ihn in einzelne Wörter (Tokens) auf
  tidytext::unnest_tokens(wort, text, to_lower = FALSE)

# Wir nehmen diese einzelnen Tokens...
sentiment_oetker <- woerter_2 %>%
  # ...packen diesen Datensatz mit dem Sentimentwortschatz zusammen...
  dplyr::inner_join(lexicon, by = "wort") %>%
  # ...berechnen den Mittelwert der Sentimentwerte...
  dplyr::summarize(sentiment = mean(sentiment)) %>%
  # ...und wählen die Spalte "sentiment" aus!
  pull(sentiment) %>%
  print()
```

</details>

---

### **Und jetzt Ihr**

Ich habe ein paar Übungen zur Textmanipulation (mittels Regex) sowie Transformation mittels dplyr und Visualisierung mit ggplot vorbereitet, mit denen Ihr Euch am Plastikdatensatz austoben könnt.
Schaut Euch das **R Markdown: 11_arbeiten_mit_text_uebungen.Rmd** (im [Übungsordner](https://download-directory.github.io/?url=https://github.com/CorrelAid/lernplattform/tree/main/uebungen){target="_blank"} unter 11_arbeiten_mit_text) an und versucht die Aufgaben darin zu bearbeiten. 


### **Zusätzliche Ressourcen**

-   [Schummelblatt: stringr](https://github.com/CorrelAid/lernplattform/blob/main/cheatsheets/06_cheatsheet-stringr.pdf){target="_blank"} (engl.)
-   [regexr.com](https://regexr.com/){target="_blank"} (engl.)


<a class="btn btn-primary btn-back-to-main" href=`r params$links$end_session`>Session beenden</a>
